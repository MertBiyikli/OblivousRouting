#include <iostream>
#include "src/graph.h"
#include "src/lp_solver/LPSolver.h"
#include "src/lp_solver/MCCF_lp_solver.h"
#include "src/tree_based/frt/raecke_frt_solver.h"
#include "src/tree_based/random_mst/raecke_mst_solver.h"
#include "src/electrical/electrical_flow_naive.h"
#include "experiments/performance/demands/DemandModel.h"
#include "experiments/performance/demands/BimodalModel.h"
#include "experiments/performance/demands/GaussianModel.h"
#include "experiments/performance/demands/GravityModel.h"
#include "experiments/performance/demands/UniformModel.h"
#include "experiments/performance/LP_Oblivious_Ratio.h"
#include "src/electrical/AMGSolver.h"
#include "src/parse_parameter.h"




int main(int argc, char **argv) {

    auto start_time = std::chrono::high_resolution_clock::now();
    auto end_time = std::chrono::high_resolution_clock::now();

    std::string err;
    auto cfg = parse_parameter(argc, argv, &err);
    if (!cfg) { std::cerr << err; return -1; } // EX_USAGE

    Graph g;
    g.readLFGFile(cfg->filename, /*undirected?*/ true);


    std::cout << "Graph loaded: " << g.getNumNodes() << " nodes, " << g.getNumEdges() << " edges.\n";

    std::unique_ptr<ObliviousRoutingSolver> solver;
    switch (cfg->solver) {
        case SolverType::ELECTRICAL_NAIVE:
            std::cout << "Running Electrical Flow (naive)...\n";
            solver = std::make_unique<ElectricalFlowNaive>();
            break;
        case SolverType::RAECKE_FRT:
            std::cout << "Running Tree-based (Raecke/FRT)...\n";
            solver = std::make_unique<RaeckeFRTSolver>();
            break;
        case SolverType::LP_APPLEGATE_COHEN:
            std::cout << "Running LP (Applegateâ€“Cohen)...\n";
            solver = std::make_unique<LPSolver>();
            break;
        case SolverType::RAECKE_RANDOM_MST:
            std::cout << "Running Tree-based (Raecke/MST)...\n";
            solver = std::make_unique<RaeckeMSTSolver>();
            break;
    }

    if ( !solver ) {
        std::cerr << "Solver not implemented.\n";
        return -1; // EX_UNAVAILABLE
    }

    // run the solver
    start_time = std::chrono::high_resolution_clock::now();
    solver->solve(g);
    end_time = std::chrono::high_resolution_clock::now();
    std::cout << "Running time: " << std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count() << " [milliseconds]" << std::endl;
    solver->storeFlow();


    // solver->printFlow();

    ObliviousRatio OR;
    OR.init(g, solver->f_e_st);
    std::cout << "Worst case demand congestion: " << OR.solve() << std::endl;

    // if a demand model is provided, compute the oblivious ratio for that demand model
    if (cfg->demand_model != DemandModelType::NONE) {
        std::vector< std::pair<int, int> > demands;
        // print out the capacities for each node
        for (const auto& v : g.getVertices()) {
            for (const auto& u : g.getVertices()) {
                if (v != u) {
                    demands.push_back({v, u});
                }
            }
        }

        // initialize demand model
        std::unique_ptr<DemandModel> demand_model;
        switch  (cfg->demand_model) {
            case DemandModelType::GRAVITY:
                demand_model = std::make_unique<GravityModel>();
                break;
            case DemandModelType::BIMODAL:
                demand_model = std::make_unique<BimodalModel>();
                break;
            case DemandModelType::GAUSSIAN:
                demand_model = std::make_unique<GaussianModel>();
                break;
            case DemandModelType::UNIFORM:
                demand_model = std::make_unique<UniformModel>();
                break;
            default:
                std::cerr << "Unknown demand model type.\n";
        }

        auto demand_map = demand_model->generate(g, demands,  1.0);
        double total_demand = 0.0;
        for (const auto& [_, d] : demand_map) {
            total_demand += d;
        }

        // compute maximum congestion generated by demand
        double max_cong;
        for (const auto& [edge, flow_map] : solver->f_e_st) {
            double edge_cong = 0.0;
            for (const auto& [commodity, value] : flow_map) {
                edge_cong += value * demand_map[commodity];
            }

            edge_cong /= g.getEdgeCapacity(edge.first, edge.second);
            if (edge_cong > max_cong) {
                max_cong = edge_cong;
            }
        }

        std::cout << "Worst case congestion for " << (argv[3] ? argv[3] : "<empty>") << " model demand: " << max_cong << std::endl;
    }

    std::cout << "MWU number of iterations: " << solver->GetIterationCount() << std::endl;

    // compute the average oracle running time
    double mean = 0;
    for (const auto& t : solver->oracle_running_times) {
        mean += t;
    }
    mean /= solver->oracle_running_times.size();
    std::cout << "Average oracle time: " << mean << " [milliseconds]" << std::endl;


    return 0;
}
